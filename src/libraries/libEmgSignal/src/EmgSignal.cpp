#include <EmgSignal.h>

	EmgSignal::EmgSignal(){
		
		std::vector< std::vector<double> > aux(16, std::vector<double>(RMS_WIN_SIZE,0)); 

		rmsWins_ = aux;

		std::vector< std::vector<double> > aux2(16, std::vector<double>(8,0)); 

		filterBuf_ = aux2;

		 //aux2(16, 1); 

		mvc_ = std::vector<double>(16,1);

		mvc_[0] = 0.0012;
		mvc_[1] = 0.0003;

		filterGain_ = 4.676379405e+04;

	}

	std::vector<double> EmgSignal::butterworth(std::vector<double> rmsValues){
		//TODO: Automate the digital filter design/process with DSPFilters or
		//some other library
		int k=0;
		std::vector<double> filteredVal(16,0) ;
		for (std::vector< std::vector<double> >::iterator it = filterBuf_.begin() ; it != filterBuf_.end(); ++it){

			double* xv = &((*it)[0]);
			double* yv = &((*it)[4]);

			xv[0] = xv[1];
			xv[1] = xv[2];
			xv[2] = xv[3];

			xv[3] = rmsValues[k] / filterGain_;

			yv[0] = yv[1];
			yv[1] = yv[2];
			yv[2] = yv[3];

			yv[3] = (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
                     + (  0.8930401556 * yv[0]) + ( -2.7801176124 * yv[1])
                     + (  2.8869063843 * yv[2]);

            filteredVal[k] = yv[3];

			k++;

			/*Generated by:   http://www-users.cs.york.ac.uk/~fisher/mkfilter

				Summary
				You specified the following parameters:

				    filtertype 	= 	Butterworth
				    passtype 	= 	Lowpass
				    ripple 	= 	
				    order 	= 	3
				    samplerate 	= 	1111
				    corner1 	= 	10
				    corner2 	= 	
				    adzero 	= 	
				    logmin 	= 
				    Command line: /www/usr/fisher/helpers/mkfilter -Bu -Lp -o 3 -a 9.0009000900e-03 0.0000000000e+00
					raw alpha1    =   0.0090009001
					raw alpha2    =   0.0090009001
					warped alpha1 =   0.0090032999
					warped alpha2 =   0.0090032999
					gain at dc    :   mag = 4.676379405e+04   phase =  -0.0000000000 pi
					gain at centre:   mag = 3.306699589e+04   phase =  -0.7500000000 pi
					gain at hf    :   mag = 0.000000000e+00

					S-plane zeros:

					S-plane poles:
						 -0.0282847008 + j   0.0489905389
						 -0.0565694016 + j   0.0000000000
						 -0.0282847008 + j  -0.0489905389

					Z-plane zeros:
						 -1.0000000000 + j   0.0000000000	3 times

					Z-plane poles:
						  0.9709598747 + j   0.0476059334
						  0.9449866350 + j   0.0000000000
						  0.9709598747 + j  -0.0476059334
	
*/


		}
		return filteredVal;
		//remember you actually have to return a vector of size 16!! one value for each sensor!
	}

	void EmgSignal::setSample(EmgData sample, int ite){

		sample_ = sample;
		stepTime_ = ite;

		configured_ = true;

	}



	void EmgSignal::clearRmsWin(){

		rmsWins_.clear();
		std::vector< std::vector<double> > aux(16, std::vector<double>(RMS_WIN_SIZE,0));
		rmsWins_ = aux;

	}

	std::vector<double> EmgSignal::rms(){


			// Spin/add RMS window
			int k = 0;// k iterates through the sample,'it' over the rms windows of each sensor (and 'i' through time)
			for (std::vector< std::vector<double> >::iterator it = rmsWins_.begin() ; it != rmsWins_.end(); ++it){
				
				if((stepTime_+1) <= RMS_WIN_SIZE){	
					(*it)[stepTime_] = sample_.data[k];
					
				}
				else{
					std::rotate((*it).begin(), (*it).begin()+1, (*it).end());
					(*it).pop_back();
					(*it).push_back(sample_.data[k]);				
				}

				k++;
			}

			double rmsVal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
			//iterate through the sample...
			int j = 0;
        	for (std::vector<float>::iterator it = sample_.data.begin() ; it != sample_.data.end(); ++it){
        		
        		double value = *it;


				if((stepTime_+1) > RMS_WIN_SIZE){
					//compute RMS of rmsWin and insert it into filteredImEmgData
					//
					//Now we shall iterate  through the sample window
        			for (std::vector<double>::iterator rmsIt = rmsWins_[j].begin() ; rmsIt != rmsWins_[j].end(); ++rmsIt){ 	
        				rmsVal[j] += (*rmsIt)*(*rmsIt);
        			}
        			rmsVal[j] = rmsVal[j] / rmsWins_[0].size(); //all rmsWins vectors should have the same size
        			rmsVal[j] = sqrt(rmsVal[j]);

				}

        		//imData.filteredImEmgData.push_back(rmsVal[j]);
        		j++;

			}
			std::vector<double> aux(std::begin(rmsVal), std::end(rmsVal));
			return aux;


	}

	std::vector<double> EmgSignal::normalizeEmgData(std::vector<double> emg){

		int count = 0;
		double aux;
		std::vector<double> normalized;
		
		for(auto i : emg){

			aux = i / mvc_[count];
			normalized.push_back(aux);

			count++;
		}

		return normalized;

	}


	std::vector<double> EmgSignal::icc(std::vector<double> normalized){

		std::vector<double> iccVec;
		for (int i = 0; i < 16; i = i+2)
		{
			if( normalized[i] <= normalized[i+1] ){
				iccVec.push_back(normalized[i]);
			}
			else{
				iccVec.push_back(normalized[i+1]);
			}
		}
		
		return iccVec;


	}

	std::vector<double> EmgSignal::iccLevel(std::vector<double> icc, int NLevels){
		
		
		std::vector<double> iccLevels;

		double div;

		int count = 0;
		for(auto iccValue: icc){

			div = 1 / NLevels;

			if(NLevels == 4){
	
				if(iccValue <= div){
					iccValue = div;
				}

				else if(iccValue <= 2 * div && iccValue > 1 * div){
					iccValue = 2*div;
				}
				else if(iccValue <= 3 * div && iccValue > 2 * div){
					iccValue = 3*div;
				}
				else if(iccValue <= 4 * div && iccValue > 3 * div){
					iccValue = 4*div;
				}			
			}

			if(NLevels == 3){
	
				if(iccValue <= div){
					iccValue = div;
				}

				else if(iccValue <= 2 * div && iccValue > 1 * div){
					iccValue = 2*div;
				}
				else if(iccValue <= 3 * div && iccValue > 2 * div){
					iccValue = 3*div;
				}
	
			}

			if(NLevels == 2){
	
				if(iccValue <= div){
					iccValue = div;
				}

				else if(iccValue <= 2 * div && iccValue > 1 * div){
					iccValue = 2*div;
				}
			}

		}


	}